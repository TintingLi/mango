lines = c(
"###### GENERAL PARAMETERS ######",
"stages            = 1:5                   # stages of the pipeline to execute",
"prefix            = mango                 # prefix for all output files",
"outdir            = NULL",
"bowtiepath        = /Users/dougphanstiel/Tools/bowtie-1.0.0/bowtie",
"bowtieref         = /Users/dougphanstiel/Tools/bowtie-1.0.0/indexes/hg19",
"bedtoolspath      = /Users/dougphanstiel/Tools/bedtools-2.17.0/bin/bedtools",
"bedtoolsgenome    = /Users/dougphanstiel/Tools/bedtools-2.17.0/genomes/human.hg19.genome",
"macs2path         = /usr/local/bin/macs2",
"chrominclude      = NULL                    # comma separated list of chromosomes to use (e.g. chr1,chr2,chr3,...).  Only these chromosomes will be processed",
"chromexclude      = NULL                    # comma separated list of chromosomes to exclude (e.g. chrM,chrY)",
"###### STAGE 1 PARAMETERS ######",
"linkerA           = GTTGGATAAG              # linker sequences to look for",
"linkerB           = GTTGGAATGT              # linker sequences to look for",
"minlength         = 15                      # min length of reads after linker trimming",
"maxlength         = 25                      # max length of reads after linker trimming",
"keepempty         = FALSE                   # Should reads with no linker be kept",
"###### STAGE 2 PARAMETERS ######",
"shortreads           = TRUE                 # should bowtie alignments be done using paramter for very short reads (~20 bp)",
"###### STAGE 4 PARAMETERS ######",
"MACS_pvalue       = 0.00001                  # MACS values",
"peakslop          = 500                      # Number of basespairs to extend peaks on both sides",
"peakinput         = NULL                     # name of user supplied peaks file",
"###### STAGE 5 PARAMETERS ######",
"distcutrangemin   = 1000                     # range in which to look for the self-ligation distance",
"distcutrangemax   = 100000                   # range in which to look for the self-ligation distance",
"biascut           = 0.05                     # Self ligation bias cutoff",
"maxPval           = 0.01                     # P-value cutoff",
"numofbins         = 30                       # number of bins for probability calculations",
"corrMethod        = BY                       # multiple hypothesis tersting correction method",
"maxinteractingdist= 10000000                 # maximum disance allowed for an interaction",
"FDR               = 0.01                     # FDR cutoff for interactions",
"minPETS           = 1                        # minimum number of PETs required for an interaction (applied after FDR filtering)",
"reportallpairs    = FALSE                    # Should all pairs be reported or just significant pairs"
)
lines
args=hash()
library('hash')
args=hash()
verbose=FALSE
for (line in lines)
{
# remove spaces
line = gsub(pattern=" ",x=line,replace="")
if (line == "")
{
next
}
else if (strsplit(line,split="")[[1]][1] == "#" )
{
next
}
else
{
lineinfo = strsplit(line,split="#")[[1]][1]
arginfo  = strsplit(lineinfo,split="=")[[1]]
args[[arginfo[1]]] = arginfo[2]
if (verbose == TRUE)
{
print(paste(arginfo[1] , "        " , arginfo[2]))
}
}
}
args
argsscript = c("bowtiepath=/path/to/bowtie",
"bowtieref=/path/to/indexes/hg19",
"bedtoolspath=/path/to/bedtools",
"bedtoolsgenome=/path/to/human.hg19.genome",
"macs2path=/path/to/macs2")
argsscript
# Define a funtion that establishes all parameters
establishParameters <-function(argscmdline,argsscript)
{
args = hash()
# determine if there is a argument file
argfile = NULL
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
if (argparts[1] == "argfile")
{
argfile = argparts[2]
}
}
# (1) first read in default parameters
args = readParameters()
# (2) overwrite with arguments in script itself
for (arg in argsscript)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# (3) overwrite with arguments froms supplied file
if (is.null(argfile) == FALSE)
{
args = readParameters(argfile,args)
}
# (4) overwrite with command line arguments
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# overwrite with command line arguments
args[["outname"]] = ""
if (args[["outdir"]] == "NULL")
{
args[["outname"]] = file.path(getwd(),args[["prefix"]])
}
if (args[["outdir"]] != "NULL")
{
args[["outname"]] = file.path( args[["outdir"]] ,args[["prefix"]])
}
# correct stages
stages = strsplit(args[["stages"]],split=":")[[1]]
if (length(stages) == 2)
{
args[["stages"]] = seq(as.numeric(stages[1]),as.numeric(stages[2]))
}
if (length(stages) == 1)
{
args[["stages"]] = as.numeric(stages[1])
}
return (args)
}
readParameters <-function(args=hash(),verbose=FALSE)
{
lines = c(
"###### GENERAL PARAMETERS ######",
"stages            = 1:5                   # stages of the pipeline to execute",
"prefix            = mango                 # prefix for all output files",
"outdir            = NULL",
"chrominclude      = NULL                    # comma separated list of chromosomes to use (e.g. chr1,chr2,chr3,...).  Only these chromosomes will be processed",
"chromexclude      = NULL                    # comma separated list of chromosomes to exclude (e.g. chrM,chrY)",
"###### STAGE 1 PARAMETERS ######",
"linkerA           = GTTGGATAAG              # linker sequences to look for",
"linkerB           = GTTGGAATGT              # linker sequences to look for",
"minlength         = 15                      # min length of reads after linker trimming",
"maxlength         = 25                      # max length of reads after linker trimming",
"keepempty         = FALSE                   # Should reads with no linker be kept",
"###### STAGE 2 PARAMETERS ######",
"shortreads           = TRUE                 # should bowtie alignments be done using paramter for very short reads (~20 bp)",
"###### STAGE 4 PARAMETERS ######",
"MACS_pvalue       = 0.00001                  # MACS values",
"peakslop          = 500                      # Number of basespairs to extend peaks on both sides",
"peakinput         = NULL                     # name of user supplied peaks file",
"###### STAGE 5 PARAMETERS ######",
"distcutrangemin   = 1000                     # range in which to look for the self-ligation distance",
"distcutrangemax   = 100000                   # range in which to look for the self-ligation distance",
"biascut           = 0.05                     # Self ligation bias cutoff",
"maxPval           = 0.01                     # P-value cutoff",
"numofbins         = 30                       # number of bins for probability calculations",
"corrMethod        = BY                       # multiple hypothesis tersting correction method",
"maxinteractingdist= 10000000                 # maximum disance allowed for an interaction",
"FDR               = 0.01                     # FDR cutoff for interactions",
"minPETS           = 1                        # minimum number of PETs required for an interaction (applied after FDR filtering)",
"reportallpairs    = FALSE                    # Should all pairs be reported or just significant pairs"
)
for (line in lines)
{
# remove spaces
line = gsub(pattern=" ",x=line,replace="")
if (line == "")
{
next
}
else if (strsplit(line,split="")[[1]][1] == "#" )
{
next
}
else
{
lineinfo = strsplit(line,split="#")[[1]][1]
arginfo  = strsplit(lineinfo,split="=")[[1]]
args[[arginfo[1]]] = arginfo[2]
if (verbose == TRUE)
{
print(paste(arginfo[1] , "        " , arginfo[2]))
}
}
}
return (args)
}
# Define a funtion that establishes all parameters
establishParameters <-function(argscmdline,argsscript)
{
args = hash()
# determine if there is a argument file
argfile = NULL
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
if (argparts[1] == "argfile")
{
argfile = argparts[2]
}
}
# (1) first read in default parameters
args = readParameters()
# (2) overwrite with arguments in script itself
for (arg in argsscript)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# (3) overwrite with arguments froms supplied file
if (is.null(argfile) == FALSE)
{
args = readParameters(argfile,args)
}
# (4) overwrite with command line arguments
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# overwrite with command line arguments
args[["outname"]] = ""
if (args[["outdir"]] == "NULL")
{
args[["outname"]] = file.path(getwd(),args[["prefix"]])
}
if (args[["outdir"]] != "NULL")
{
args[["outname"]] = file.path( args[["outdir"]] ,args[["prefix"]])
}
# correct stages
stages = strsplit(args[["stages"]],split=":")[[1]]
if (length(stages) == 2)
{
args[["stages"]] = seq(as.numeric(stages[1]),as.numeric(stages[2]))
}
if (length(stages) == 1)
{
args[["stages"]] = as.numeric(stages[1])
}
return (args)
}
argsscript = c("bowtiepath=/path/to/bowtie",
"bowtieref=/path/to/indexes/hg19",
"bedtoolspath=/path/to/bedtools",
"bedtoolsgenome=/path/to/human.hg19.genome",
"macs2path=/path/to/macs2")
argscmdline = NULL
args
args=NULL
args = establishParameters(argscmdline,argsscript)
args
library(mango)
if (file.exists("test.sort") == TRUE){file.remove("test.sort")}
system("sort test > test.sort")
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
system("sort ~/Desktop/test > ~/Desktop/test.sort")
system("qwack ~/Desktop/test > ~/Desktop/test.sort")
?system
system("qwack ~/Desktop/test > ~/Desktop/test.sort",show.output.on.console = FALSE)
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stdout = TRUE)
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE)
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE)
if (file.exists("~/Desktop/test.sort") == TRUE){print "yes"}
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE)
if (file.exists("~/Desktop/test.sort") == TRUE){print "yes"}
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE)
if (file.exists("~/Desktop/test.sort") == TRUE) {print ("yes")}
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
try(system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE))
if (file.exists("~/Desktop/test.sort") == TRUE){file.remove("~/Desktop/test.sort")}
if (file.exists("~/Desktop/test.sort") == TRUE) {print ("yes")}
system("qwack ~/Desktop/test > ~/Desktop/test.sort",ignore.stderr = TRUE)
if (file.exists("~/Desktop/test.sort") == TRUE) {print ("yes")}
?splitBedpe
bedpein = "~/Desktop/testdir/test.bedpe"
outname = "~/Desktop/testdir/test"
splitBedpe(bedpein,outname,printreads = FALSE , bool printpets = TRUE)
splitBedpe(bedpein,outname,printreads = FALSE ,  printpets = TRUE)
bedpein
library(mango)
library(mango)
# runs mango chia pet analysis pipeline
library("Rcpp")
library("hash")
library("mango")
##################################### initialization #####################################
argsscript = c(
"bowtiepath=/path/to/bowtie",
"bowtieref=/path/to/indexes/hg19",
"bedtoolspath=/path/to/bedtools",
"bedtoolsgenome=/path/to/human.hg19.genome",
"macs2path=/path/to/macs2"
)
print ("Starting mango ChIA PET analysis tool")
Sys.time()
set.seed(1)
argscmdline <- commandArgs(trailingOnly = TRUE)
argscmdline
args = establishParameters(argscmdline,argsscript)
# Define a funtion that establishes all parameters
establishParameters <-function(argscmdline,argsscript)
{
args = hash()
# determine if there is a argument file
argfile = NULL
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
if (argparts[1] == "argfile")
{
argfile = argparts[2]
}
}
# (1) first read in default parameters
args = readParameters()
# (2) overwrite with arguments in script itself
for (arg in argsscript)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# (3) overwrite with arguments froms supplied file
if (is.null(argfile) == FALSE)
{
args = readParameters(argfile,args)
}
# (4) overwrite with command line arguments
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# overwrite with command line arguments
args[["outname"]] = ""
if (args[["outdir"]] == "NULL")
{
args[["outname"]] = file.path(getwd(),args[["prefix"]])
}
if (args[["outdir"]] != "NULL")
{
args[["outname"]] = file.path( args[["outdir"]] ,args[["prefix"]])
}
# correct stages
stages = strsplit(args[["stages"]],split=":")[[1]]
if (length(stages) == 2)
{
args[["stages"]] = seq(as.numeric(stages[1]),as.numeric(stages[2]))
}
if (length(stages) == 1)
{
args[["stages"]] = as.numeric(stages[1])
}
return (args)
}
args = establishParameters(argscmdline,argsscript)
args
# Define a funtion that establishes all parameters
establishParameters <-function(argscmdline,argsscript)
{
args = hash()
# determine if there is a argument file
argfile = NULL
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
if (argparts[1] == "argfile")
{
argfile = argparts[2]
}
}
# (1) first read in default parameters
args = readParameters()
# (2) overwrite with arguments in script itself
for (arg in argsscript)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# (3) overwrite with arguments froms supplied file
if (is.null(argfile) == FALSE)
{
args = readParameters(argfile)
}
# (4) overwrite with command line arguments
for (arg in argscmdline)
{
argparts = strsplit(arg,split="=")[[1]]
args[[argparts[1]]] = argparts[2]
}
# overwrite with command line arguments
args[["outname"]] = ""
if (args[["outdir"]] == "NULL")
{
args[["outname"]] = file.path(getwd(),args[["prefix"]])
}
if (args[["outdir"]] != "NULL")
{
args[["outname"]] = file.path( args[["outdir"]] ,args[["prefix"]])
}
# correct stages
stages = strsplit(args[["stages"]],split=":")[[1]]
if (length(stages) == 2)
{
args[["stages"]] = seq(as.numeric(stages[1]),as.numeric(stages[2]))
}
if (length(stages) == 1)
{
args[["stages"]] = as.numeric(stages[1])
}
return (args)
}
lines = ?readLines
?readLines
library(mango)
args
args[["outname"]] = "/Users/dougphanstiel/Desktop/mango2014test/NH.K562_RAD21_K562_std_2.1"
args[["macs2path"]] = "/usr/local/bin/macs2"
outname         = args[["outname"]]
macs2path       = args[["macs2path"]]
tagAlignfile       = paste(outname,".tagAlign",sep="")
bedpefilesortrmdup = paste(outname ,".sort.rmdup.bedpe",sep="")
MACS_pvalue     = args[["MACS_pvalue"]]
bedtoolspath = "/Users/dougphanstiel/Tools/bedtools-2.17.0/bin/bedtools"
bedtoolsgenome = "/Users/dougphanstiel/Tools/bedtools-2.17.0/genomes/human.hg19"
peakslop
args[["peakslop"]] = "/Users/dougphanstiel/Desktop/mango2014test/NH.K562_RAD21_K562_std_2.1_peaks.slopPeak"
peakslop        = args[["peakslop"]]
# call peaks
print ("calling peaks")
callpeaks(macs2path=macs2path,tagAlignfile,outname,pvalue=MACS_pvalue,
bedtoolspath=bedtoolspath,bedtoolsgenome=bedtoolsgenome,
peakslop=peakslop)
peaksfile
peaksfileslop
print ("extending peaks")
extendpeaks(peaksfile,peaksfileslop,bedtoolspath=bedtoolspath,
bedtoolsgenome=bedtoolsgenome,peakslop=peakslop)
bedtoolsgenome = "/Users/dougphanstiel/Tools/bedtools-2.17.0/genomes/human.hg19.genome"
# extend and merge peaks according to peakslop
print ("extending peaks")
extendpeaks(peaksfile,peaksfileslop,bedtoolspath=bedtoolspath,
bedtoolsgenome=bedtoolsgenome,peakslop=peakslop)
library(mango)
# Define a function that calls peaks using macs2
callpeaks <- function(macs2path,tagAlignfile,peaksfile,pvalue=.00001,
bedtoolspath,bedtoolsgenome,peakslop=0)
{
# call peaks
command = paste(macs2path," callpeak -t ",tagAlignfile," -nomodel --shiftsize 100 -f BED -n ",peaksfile," -p ",pvalue,sep=" ")
print (command)
system(command)
# now shorten peak names
peaks = read.table(paste(peaksfile,"_peaks.narrowPeak",sep=""),header=FALSE,sep="\t")
peaks[,4] = paste("peak_",1:nrow(peaks),sep="")
write.table(peaks,file=paste(peaksfile,"_peaks.narrowPeak",sep=""),quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE,append=FALSE)
#   # remove unneccesary files
#   listofsuffixes = c("peaks.xls","summits.bed","model.r","","")
#   for (suf in listofsuffixes)
#   {
#     fname = paste(peaksfile,suf,sep="_")
#     if (file.exists(fname) == TRUE)
#     {
#         file.remove(fname)
#     }
#   }
}
callpeaks(macs2path=macs2path,tagAlignfile,outname,pvalue=MACS_pvalue,
bedtoolspath=bedtoolspath,bedtoolsgenome=bedtoolsgenome,
peakslop=peakslop)
# Define a function that calls peaks using macs2
callpeaks <- function(macs2path,tagAlignfile,peaksfile,pvalue=.00001,
bedtoolspath,bedtoolsgenome,peakslop=0)
{
# call peaks
command = paste(macs2path," callpeak -t ",tagAlignfile," --nomodel --shiftsize 100 -f BED -n ",peaksfile," -p ",pvalue,sep=" ")
print (command)
system(command)
# now shorten peak names
peaks = read.table(paste(peaksfile,"_peaks.narrowPeak",sep=""),header=FALSE,sep="\t")
peaks[,4] = paste("peak_",1:nrow(peaks),sep="")
write.table(peaks,file=paste(peaksfile,"_peaks.narrowPeak",sep=""),quote=FALSE,sep="\t",col.names=FALSE,row.names=FALSE,append=FALSE)
#   # remove unneccesary files
#   listofsuffixes = c("peaks.xls","summits.bed","model.r","","")
#   for (suf in listofsuffixes)
#   {
#     fname = paste(peaksfile,suf,sep="_")
#     if (file.exists(fname) == TRUE)
#     {
#         file.remove(fname)
#     }
#   }
}
callpeaks(macs2path=macs2path,tagAlignfile,outname,pvalue=MACS_pvalue,
bedtoolspath=bedtoolspath,bedtoolsgenome=bedtoolsgenome,
peakslop=peakslop)
library(mango)
files = glob(("~/Dropbox/mangoRpackage/data/publishedpairs/processed/*.txt")
files = glob("~/Dropbox/mangoRpackage/data/publishedpairs/processed/*.txt")
list.files(path = "~/Dropbox/mangoRpackage/data/publishedpairs/processed/", pattern = "*.txt")
list.files(path = "~/Dropbox/mangoRpackage/data/publishedpairs/processed/", pattern = "*.txt")
pairs = list.files(path = "~/Dropbox/mangoRpackage/data/publishedpairs/processed/", pattern = "*.txt")
datapath = "~/Dropbox/mangoRpackage/data/publishedpairs/processed/"
pairs = list.files(path = datapath, pattern = "*.txt")
for (p in pairs)
{
print (p)
filename = paste(datapath,p,sep="")
data = read.table(filename,header=FALSE,sep="\t")
}
head(p)
head(data)
